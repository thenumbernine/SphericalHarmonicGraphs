#! /usr/bin/env rua

local cmdline = require 'ext.cmdline'.validate{
	l = {desc='how many l levels to build'},
	gl = {desc='which gl backend to use'},
}(...)

local vec3d = require 'vec-ffi.vec3d'
local gl = require 'gl.setup'(cmdline.gl or 'OpenGL')
local GLProgram = require 'gl.program'
local GLSceneObject = require 'gl.sceneobject'
local sphericalHarmonics = require 'sphericalharmonics'

local lmax = tonumber(cmdline.l) or 3

local idiv = 360
local jdiv = 180

local SHApp = require 'glapp.orbit'():subclass()
SHApp.title = 'Spherical Harmonics Graph'
SHApp.viewDist = lmax

local vtxcache = {}
local vtx = |l,m,i,j| vtxcache
	-> (|t| t[l] ??:= {})
	-> (|t| t[m] ??:= {})
	-> (|t| t[i] ??:= {})
	-> (|t| t[j] ??:=
		i/idiv*2*math.pi, j/jdiv*math.pi -> (|phi, theta|
			sphericalHarmonics.real(l, m, theta, phi)
			-> (|Y|
				math.abs(Y)
				-> (|r| {
					Y = Y,
					vec = vec3d(
						r * math.sin(theta) * math.cos(phi),
						r * math.sin(theta) * math.sin(phi),
						r * math.cos(theta)
					),
				})
			)
		)
	)

local normalcache = {}
local normal = |l,m,i,j| normalcache
	-> (|t| t[l] ??:= {})
	-> (|t| t[m] ??:= {})
	-> (|t| t[i] ??:= {})
	-> (|t| t[j] ??:=
		-(vec3d(vtx(l,m,i+1,j).vec) - vec3d(vtx(l,m,i-1,j).vec))
		:cross(vec3d(vtx(l,m,i,j+1).vec) - vec3d(vtx(l,m,i,j-1).vec))
		:normalize()
	)

SHApp.initGL = |:, ...| do
	program = GLProgram{
		version = 'latest',
		precision = 'best',
		vertexCode = [[
in vec3 vertex, normal, color;
uniform mat4 projMat, mvMat;
out vec3 colorv, normalv;
void main() {
	vec4 worldposv = mvMat * vec4(vertex, 1.);
	colorv = color;
	normalv = normalize((mvMat * vec4(normal, 0.)).xyz);
	gl_Position = projMat * worldposv;
}
]],
		fragmentCode = [[
in vec3 normalv, colorv;
out vec4 fragColor;
void main() {
	fragColor = vec4(max(.1, abs(normalv.z)) * colorv, 1.);
}
]],
	}:useNone()

	sceneobjs = table()
	for l=0,lmax do
		for m=-l,l do
			print('building l='..l..' m='..m)
			local vofs = vec3d(m,lmax/2-l,0)
			--gl.glPolygonMode(gl.GL_FRONT_AND_BACK, gl.GL_LINE)

			local colors = table()
			local vertexes = table()
			local normals = table()

			for j=0,jdiv do
				for i=0,idiv do
					local vsrc = vtx(l,m,i,j)
					if vsrc.Y >= 0 then
						colors:append{1,0,0}
					else
						colors:append{0,1,1}
					end
					normals:append{normal(l,m,i,j):unpack()}
					vertexes:append{(vsrc.vec + vofs):unpack()}
				end
			end

			local indexes = table()
			for i=0,idiv-1 do
				local index = table()
				indexes:insert(index)
				for j=0,jdiv do
					for iofs=0,1 do
						index:insert((i + iofs) + (idiv + 1) * j)
					end
				end
			end

			sceneobjs:insert(GLSceneObject{
				program = program,
				vertexes = {
					data = vertexes,
					count = #vertexes / 3,
					dim = 3,
				},
				geometries = indexes:mapi(function(index)
					return {
						mode = gl.GL_TRIANGLE_STRIP,
						indexes = {
							data = index,
						},
					}
				end),
				attrs = {
					color = {
						buffer = {
							data = colors,
							count = #colors / 3,
							dim = 3,
						},
					},
					normal = {
						buffer = {
							data = normals,
							count = #normals / 3,
							dim = 3,
						},
					},
				},
			})
		end
	end

	gl.glEnable(gl.GL_DEPTH_TEST)
end

SHApp.update = |:| do
	SHApp.super.update(self)
	gl.glClear(gl.GL_COLOR_BUFFER_BIT | gl.GL_DEPTH_BUFFER_BIT)
	for _,obj in ipairs(sceneobjs) do
		obj.uniforms.mvMat = self.view.mvMat.ptr
		obj.uniforms.projMat = self.view.projMat.ptr
		obj:draw()
	end
end

return SHApp():run()
